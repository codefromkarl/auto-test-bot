# 02 - 三层架构详细设计

## 一、架构层次

```
┌─────────────────────────────────────────┐
│        Layer 1: 业务编排层 (RF)          │
│  • Robot Framework (.robot文件)          │
│  • 业务DSL，描述验收流程              │
│  • 零代码细节，只允许业务关键字        │
└─────────────────────────────────────────┘
                ↓ 协议传输 (ScenarioContext)
┌─────────────────────────────────────────┐
│  Layer 2: 适配与调度层 (Python)       │
│  • NaohaiAdapter.py (胶水层)         │
│  • Sync-to-Async桥接                 │
│  • AIGC增强能力 (插件化)            │
│  • 生命周期管理                        │
└─────────────────────────────────────────┘
                ↓ 事件驱动调用
┌─────────────────────────────────────────┐
│  Layer 3: 核心执行引擎 (现有Bot)       │
│  • Playwright封装                    │
│  • MetricsHybridLocator (三级定位)     │
│  • MCP诊断系统                       │
│  • 契约门禁                         │
│  • 登录态管理                        │
└─────────────────────────────────────────┘
```

## 二、各层职责边界

### 2.1 Layer 1: 业务编排层

| 职责 | 具体内容 | 禁止事项 |
|------|----------|----------|
| 编排业务流程 | 根据功能清单编写测试脚本 | 直接写CSS/XPath |
| 定义验收标准 | 明确期望结果和校验点 | 实现复杂逻辑 |
| 管理测试数据 | 使用业务友好的数据格式 | 调用底层API |

### 2.2 Layer 2: 适配与调度层

| 职责 | 具体内容 | 接口约束 |
|------|----------|----------|
| 同步异步桥接 | 将RF同步调用转为异步 | 统一错误处理 |
| 插件生命周期 | 管理插件的加载/执行/清理 | 标准插件接口 |
| 上下文传递 | 维护跨层数据一致性 | 只通过ScenarioContext |
| 资源管理 | 浏览器实例复用 | Suite级别单例 |

### 2.3 Layer 3: 核心执行引擎

| 职责 | 具体内容 | 保留能力 |
|------|----------|----------|
| 浏览器操作 | 元素定位、交互、导航 | Playwright封装 |
| 定位策略 | 三级定位逻辑 | MetricsHybridLocator |
| 失败诊断 | DOM分析、证据收集 | MCP诊断系统 |
| 质量门禁 | 契约校验、覆盖率统计 | 契约门禁 |

## 三、关键设计决策

### 3.1 为什么要三层？
1. **职责单一**：每层只做自己擅长的事
2. **依赖清晰**：通过协议接口交互，避免耦合
3. **演进独立**：每层可以独立升级

### 3.2 为什么RF只在Layer 1？
1. **业务友好**：DSL接近自然语言
2. **限制复杂度**：防止在RF中写复杂逻辑
3. **便于协作**：产品、运营可以参与

### 3.3 为什么Python在Layer 2&3？
1. **处理复杂能力**：异步、文件、API调用
2. **工程化资产**：现有代码直接复用
3. **性能考虑**：减少RF解释器开销

## 四、跨层通信机制

### 4.1 ScenarioContext协议
```python
# 跨层数据传输的标准格式
{
    "test_id": "test_video_001",
    "business_flow": "video_creation",
    "test_data": {...},
    "execution_options": {...},
    "expected_results": {...}
}
```

### 4.2 事件总线
```python
# Layer 3 → Layer 2 的事件流
{
    "type": "locator.gold_hit",
    "data": {...}
}
{
    "type": "locator.silver_fallback",
    "data": {...}
}
{
    "type": "locator.bronze_fallback",
    "data": {...}
}
```

## 五、数据流向图

```
业务用例(.robot)
      ↓ 调用关键字
NaohaiAdapter
      ↓ 传递ScenarioContext
插件系统
      ↓ 生成配置
现有Bot
      ↓ 执行操作
Playwright
      ↓ 返回结果
Metrics系统
      ↓ 收集指标
Reporter
      ↓ 生成报告
Dashboard
      ↓ 可视化展示
```

## 六、扩展点设计

### 6.1 水平扩展
- **新插件**：可以独立开发新的AIGC能力
- **新适配器**：可以支持其他测试框架
- **新执行器**：可以支持其他浏览器引擎

### 6.2 垂直扩展
- **深度定位**：可以引入视觉定位、AI定位
- **智能优化**：可以加入机器学习优化定位
- **预测调度**：可以引入任务优先级预测