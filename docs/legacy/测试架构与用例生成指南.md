# 闹海测试架构与用例生成指南

更新时间：2025-12-16
文档目的：建立清晰的测试架构，规范用例生成流程，避免重复与混淆

## 1. 测试架构总览

### 1.1 分层测试模型

```
┌─────────────────────────────────────────────────────┐
│                  CI 执行层                           │
├─────────────────┬─────────────────┬─────────────────┤
│   冒烟层(AT)    │   功能层(FC)    │   回归层(RT)    │
│  (主链路验证)   │  (功能点验收)   │  (场景覆盖)     │
│                │                │                │
│ • 快速失败     │ • 需求映射      │ • 端到端场景   │
│ • 5-10条/模块  │ • 精确断言      │ • 数据驱动      │
│ • 基础覆盖     │ • 独立运行      │ • 定时执行      │
└─────────────────┴─────────────────┴─────────────────┘
```

### 1.2 用例类型定义

| 类型 | 编号规范 | 执行频率 | 失败影响 | 维护成本 |
|------|----------|----------|----------|----------|
| **AT** (冒烟) | AT-NH-### | 每次CI | 阻断后续 | 低 |
| **FC** (功能) | FC-NH-### | 每次CI | 单个功能 | 中 |
| **RT** (回归) | RT-NH-### | 定时/PR | 场景失败 | 高 |

### 1.3 CI编排规则

```yaml
# CI Pipeline 执行顺序
stages:
  - stage: "smoke"
    when: "always"
    run:
      - kind: "AT"
      - parallel: true  # AT用例并行执行
    on_failure: "STOP_PIPELINE"  # AT失败立即阻断

  - stage: "feature"
    when: "on_success(smoke)"
    run:
      - kind: "FC"
      - parallel: true
    on_failure: "CONTINUE"  # FC失败不阻断其他FC用例

  - stage: "regression"
    when: "manual OR schedule(daily)"
    run:
      - kind: "RT"
      - serial: true  # RT用例串行执行
```

### 1.4 DSL能力声明

**当前支持的DSL能力（v1.0）：**
- ✅ 支持基础actions: `open_page`, `click`, `input`, `wait_for`, `screenshot`
- ✅ 支持单selector格式：`selector: "css-selector"`
- ❌ 不支持多候选selector（逗号分隔）
- ❌ 不支持`include`/`reuse_phase`/`template`
- ❌ 不支持动态变量替换（除${test.url}等基础变量）

**复用机制当前方案：**
- 通过脚本生成YAML，避免重复代码
- 公共前置步骤在`scripts/templates/`目录维护
- 后续版本v1.1.0计划引入include机制

### 1.3 核心设计原则

1. **单一职责原则**：每个用例只验证一个明确目标
2. **层级独立原则**：冒烟失败不应影响功能用例的定位
3. **前置复用原则**：通过共享片段减少重复代码
4. **断言精确原则**：每个用例的断言必须直接对应测试目标

## 2. 用例生成规范

### 2.1 冒烟用例（AT系列）标准

**目的**：验证系统核心链路可用性
**特点**：快、准、稳

#### 2.1.1 基础结构模板

```yaml
workflow:
  id: "AT-NH-001"           # 强唯一标识
  kind: "AT"                # AT/FC/RT - 显式类型标识
  entrypoint: "story_list"   # 模块/页面域
  title: "剧本列表冒烟"       # 可读标题（非唯一）
  description: "验证从登录到剧本列表页的主链路可达性"
  coverage_level: "L0"       # AT通常L0-L1
  data_strategy: "Readonly"  # Readonly/Ephemeral/Shared

  phases:
    - name: "open_and_verify_login"
      description: "打开站点并验证登录态"
      steps:
        - action: "open_page"
          url: "${test.url}"
          timeout: ${test.timeout.page_load}

        - action: "wait_for"
          condition:
            selector: "body"
            visible: true
          timeout: ${test.timeout.element_load}

        - action: "assert_logged_in"

        - action: "screenshot"
          name: "login_verified"

    - name: "reach_target_page"
      description: "到达目标页面"
      steps:
        # 导航步骤（当前只支持单selector）
        - action: "click"
          selector: ".nav-item:has-text('AI创作')"  # 优先使用稳定选择器
          timeout: ${test.timeout.element_load}

        # 等待页面标识
        - action: "wait_for"
          condition:
            selector: "text=剧本列表"  # 页面标识符
            visible: true
          timeout: ${test.timeout.page_load}

        - action: "screenshot"
          name: "page_reached"
```

#### 2.1.2 编写要点

1. **最小断言集**：只验证"能否到达"，不验证"内容对否"
2. **快速失败**：每个导航步骤后立即验证
3. **无数据依赖**：不创建、修改、删除业务数据
4. **超时控制**：每个步骤独立超时，避免累积等待

### 2.2 功能用例（FC系列）标准

**目的**：验证具体功能点的正确性
**特点**：准、细、全

#### 2.2.1 基础结构模板

```yaml
workflow:
  id: "FC-NH-002"           # 强唯一标识
  kind: "FC"                # AT/FC/RT - 显式类型标识
  feature_id: "FC-NH-002"   # 功能点ID（与id一致）
  entrypoint: "story_list"   # 模块/页面域
  title: "剧本卡片展示验证"    # 可读标题
  description: "FC-NH-002：验证剧本列表页卡片正常展示"
  coverage_level: "L1"       # FC通常L1-L2
  data_strategy: "Readonly"  # Readonly/Ephemeral/Shared
  requirement_id: "REQ-NH-XXX"  # 需求系统ID（可选）

  phases:
    - name: "setup"
      description: "前置准备（通过脚本生成复用AT的前置）"
      steps:
        # 当前通过脚本生成AT的前置步骤
        # TODO: v1.1.0将支持 include 机制
        - action: "open_page"
          url: "${test.url}"
          timeout: ${test.timeout.page_load}

        - action: "wait_for"
          condition:
            selector: "body"
            visible: true
          timeout: ${test.timeout.element_load}

        - action: "assert_logged_in"

        - action: "click"
          selector: ".nav-item:has-text('AI创作')"
          timeout: ${test.timeout.element_load}

        - action: "wait_for"
          condition:
            selector: "text=剧本列表"
            visible: true
          timeout: ${test.timeout.page_load}

    - name: "verify_function"
      description: "验证功能点"
      steps:
        # 精确定位功能元素
        - action: "wait_for"
          condition:
            selector: ".list-item:not(.add-item)"  # 剧本卡片选择器
            visible: true
          timeout: ${test.timeout.element_load}

        - action: "screenshot"
          name: "function_verified"
```

#### 2.2.2 断言分级标准

| 覆盖等级 | 验证深度 | 示例 |
|----------|----------|------|
| **L0** | 页面可达 | `selector="[data-testid='page-story-list']"` |
| **L1** | 元素存在 | `selector="[data-testid='story-card']"` |
| **L2** | 交互响应 | 点击后验证状态变化 |
| **L3** | 端到端 | 完整创建/编辑/删除流程 |

### 2.3 回归用例（RT系列）标准

**目的**：验证跨模块业务场景
**特点**：全、真、稳

#### 2.3.1 场景驱动设计

```yaml
workflow:
  name: "RT-NH-XXX_[场景名称]"
  description: "[业务场景]：端到端验证"

  scenarios:
    - name: "create_to_publish"
      description: "创建剧本→生成分镜→导出视频"
      data_driven: true
```

## 3. 选择器策略与规范

### 3.1 优先级策略

| 优先级 | 选择器类型 | 稳定性 | 示例 | 当前支持 |
|--------|------------|--------|------|----------|
| 1 | data-testid | ★★★★★ | `[data-testid='submit-btn']` | ✅ 推荐使用 |
| 2 | 语义属性 | ★★★★☆ | `[role='button'][aria-label='提交']` | ✅ 可用 |
| 3 | 文本+结构 | ★★★☆☆ | `.modal:has-text('确认')` | ✅ 可用 |
| 4 | CSS类 | ★★☆☆☆ | `.btn-primary` | ✅ 备选 |
| 5 | XPath | ★☆☆☆☆ | `//div[contains(@class, 'modal')]` | ❌ 不支持 |

### 3.2 选择器执行语义

**当前DSL v1.0限制：**
- 只支持单selector字符串：`selector: "css-selector"`
- 不支持多候选格式（逗号分隔）
- 不支持XPath（Playwright支持但DSL未开放）

**选择器稳定性承诺：**
- `data-testid` 属于测试契约：**允许新增，禁止随意改名/删除**
- 如需改动必须同步更新用例并在PR标注
- 建议在code review中增加test-id变更检查

**当前推荐写法（单selector）：**
```yaml
# 优先使用data-testid（如果有）
selector: "[data-testid='nav-ai-create']"

# 其次使用语义属性
selector: "[role='button'][aria-label='AI创作']"

# 再次使用文本+结构
selector: ".nav-item:has-text('AI创作')"

# 最后使用CSS类
selector: ".btn-primary"
```

**v1.1.0计划支持的多候选格式（暂不可用）：**
```yaml
# 未来版本将支持
selectors:
  - "[data-testid='nav-ai-create']"
  - "[role='button'][aria-label='AI创作']"
  - ".nav-item:has-text('AI创作')"
```

### 3.3 选择器命名规范

```yaml
# 页面级标识
data-testid="page-{模块名}"
  示例：data-testid="page-story-list"

# 组件级标识
data-testid="component-{组件名}"
  示例：data-testid="component-create-modal"

# 元素级标识
data-testid="{功能}-{元素类型}"
  示例：data-testid="submit-btn"
  示例：data-testid="story-card"
  示例：data-testid="input-story-name"
```

## 4. 复用机制设计

### 4.1 前置步骤复用

#### 当前方案：脚本生成（v1.0）

**目录结构：**
```
scripts/
├── templates/
│   ├── enter_story_list.yaml    # 公共前置模板
│   └── verify_login.yaml       # 其他公共片段
└── generate_workflows.py        # 生成脚本
```

**生成规则：**
1. 所有FC用例的前置步骤由脚本自动插入
2. 公共前置在`templates/`目录维护，单一源头
3. 生成时自动检查前置重复率，超过30%报错

#### 未来方案：include指令（v1.1.0计划）

```yaml
# 被复用片段定义
shared_phases:
  enter_story_list:
    description: "进入剧本列表页"
    steps:
      - action: "open_page"
        url: "${test.url}"
        # ...完整步骤

# 使用复用
phases:
  - name: "enter_story_list"
    include: "shared_phases.enter_story_list"
```

**触发条件：**
- FC用例数量 > 20
- 或前置重复率 > 30%
- 或达到v1.1.0里程碑

### 4.2 参数化模板

```yaml
# templates/page_navigation.yaml
template:
  name: "navigate_to_page"
  description: "导航到指定页面"
  parameters:
    - name: "page_name"
      type: "string"
      required: true
    - name: "nav_text"
      type: "string"
      required: true
  steps:
    - action: "click"
      selector: "[data-testid='nav-${page_name}'], .nav:has-text('${nav_text}')"
```

## 5. 用例生成流程

### 5.1 需求分析阶段

1. **需求分解**
   - 识别核心链路 → 生成AT用例
   - 识别功能点 → 生成FC用例
   - 识别业务场景 → 生成RT用例

2. **覆盖度规划**
   ```
   功能清单 → 测试点映射 → 用例编号分配
   ```

### 5.2 用例编写阶段

1. **选择器评估**
   - 检查是否已有data-testid
   - 确定备选选择器方案
   - 记录选择器风险点

2. **断言设计**
   - 明确覆盖等级(L0-L3)
   - 设计正反断言
   - 考虑异常场景

3. **依赖分析**
   - 识别数据依赖
   - 设计清理机制
   - 标记执行顺序

### 5.3 评审与优化

1. **去重检查**
   - 前置步骤是否可复用
   - 断言是否有重叠
   - 选择器是否可优化

2. **健壮性评估**
   - 超时设置是否合理
   - 异常处理是否完备
   - 并发执行是否安全

## 6. 维护与演进

### 6.1 版本管理

```
v1.0.0 - 基础架构建立
v1.1.0 - 引入复用机制
v1.2.0 - 选择器优化
v2.0.0 - 智能化升级
```

### 6.2 监控指标

1. **稳定性指标**
   - 用例通过率
   - 选择器失败率
   - 超时异常率

2. **效率指标**
   - 平均执行时间
   - 并发执行能力
   - 维护成本占比

### 6.3 持续改进

1. **短期优化**（1-2周）
   - 补充data-testid标识
   - 统一选择器格式
   - 建立共享模板

2. **中期优化**（1-2月）
   - 实现include机制
   - 引入参数化模板
   - 建立监控体系

3. **长期优化**（3-6月）
   - 智能选择器生成
   - 自动化覆盖率分析
   - 测试数据智能管理

## 7. 附录

### 7.1 快速检查清单

**基础结构检查：**
- [ ] workflow.id是否唯一且符合规范（AT-NH-###/FC-NH-###/RT-NH-###）
- [ ] workflow.kind是否正确（AT/FC/RT）
- [ ] workflow.coverage_level是否合适（AT:L0-L1, FC:L1-L2, RT:L2-L3）
- [ ] workflow.data_strategy是否明确（Readonly/Ephemeral/Shared）

**选择器检查：**
- [ ] 是否优先使用data-testid
- [ ] 是否符合DSL当前能力（只支持单selector，不支持XPath）
- [ ] 是否包含稳定性说明

**复用检查：**
- [ ] FC用例前置重复率是否<30%
- [ ] 是否使用了scripts/templates/中的公共模板
- [ ] 是否通过脚本生成而非手写重复代码

**质量检查：**
- [ ] 断言是否精准对应测试目标
- [ ] 超时设置是否合理
- [ ] 截图点是否标准化（AT:login+page, FC:pre/post）
- [ ] 文档描述是否清晰

### 7.2 常见问题

**Q: AT和FC用例的前置步骤重复怎么办？**
A: 优先使用include复用；暂时无法复用时，确保一致性并通过脚本检查。

**Q: 页面文案经常变更导致用例失效？**
A: 采用多候选选择器，将data-testid作为首选，文案作为备选。

**Q: 如何确定一个功能需要几个用例？**
A: 按测试维度分解：可用性(AT)、正确性(FC)、场景性(RT)，避免单用例多目标。

---

> 本文档旨在建立清晰的测试架构，减少重复与混淆。所有用例生成应严格遵循此规范。